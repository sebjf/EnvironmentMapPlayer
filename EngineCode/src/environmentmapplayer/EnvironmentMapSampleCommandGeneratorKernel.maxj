package environmentmapplayer;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

public class EnvironmentMapSampleCommandGeneratorKernel extends Kernel {

	protected EnvironmentMapSampleCommandGeneratorKernel(KernelParameters parameters) throws Exception {
		super(parameters);

		flush.disabled();

		final int tile_width = 8;
		final int max_mip_level = 9;

		/* Read sample parameters from ray caster */

		DFEVar plane = io.input("plane", dfeUInt(8));
		DFEVar miplevel = io.input("miplevel", dfeUInt(8));
		DFEVar u = io.input("u", dfeFloat(8, 24));
		DFEVar v = io.input("v", dfeFloat(8, 24));

	/*	plane.simWatch("plane");
		miplevel.simWatch("mip");
		u.simWatch("u");
		v.simWatch("v");*/

		/* Compute basic parameters about the mip map in use for determining the memory address */

		DFEVar face_width_in_pixels = KernelMath.pow2(miplevel, dfeFloat(8,24));
		DFEVar face_width_in_tiles = face_width_in_pixels / tile_width;
		DFEVar tiles_per_face = face_width_in_tiles * face_width_in_tiles;

		/* Based on the mip level, determine which tile contains the sample */

		DFEVar tile_column = KernelMath.floor(u * face_width_in_tiles);
		DFEVar tile_row = KernelMath.floor(v * face_width_in_tiles);

		/* Calculate the offset into the tile of the individual sample */

		DFEVar tile_u = KernelMath.floor(u * face_width_in_pixels) - (tile_width * tile_column);
		DFEVar tile_v = KernelMath.floor(v * face_width_in_pixels) - (tile_width * tile_row);

		/* Convert these coordinate sets into memory addresses */

		DFEVar tile_offset_in_tiles = (tile_row * face_width_in_tiles) + tile_column; //In the current implementation one tile is one burst
        DFEVar face_offset_in_tiles = plane.cast(dfeFloat(8,24)) * tiles_per_face;

        //Calculate the difference in size between two sequences of mip maps, to get the offset from the start (highest mip map) of the memory
        int mip_sequence_size_max = (int)((1 - Math.pow(4, max_mip_level + 1)) / (1 - 4));
        //DFEVar mip_sequence_size_actual = (1 - KernelMath.pow2( KernelMath.pow2(miplevel + 1, dfeFloat(8,24)), dfeFloat(8,24))) / (1 - 4);

        DFEVar mip_size_inner = KernelMath.pow2(miplevel + 1, dfeFloat(8,24));
        DFEVar mip_size_outer = mip_size_inner * mip_size_inner;
        DFEVar nominator = (1 - mip_size_outer);
        DFEVar mip_sequence_size_actual = nominator / (1-4);

        DFEVar mip_diff_size = mip_sequence_size_max - mip_sequence_size_actual;
        DFEVar mip_offset_in_tiles = mip_diff_size * (6/tile_width^2);


        DFEVar addr_burst = KernelMath.floor(tile_offset_in_tiles + face_offset_in_tiles + mip_offset_in_tiles);
        DFEVar addr_pixel = KernelMath.floor(tile_u + (tile_v * tile_width));

      /*  addr_burst.simWatch("addr");
        addr_pixel.simWatch("pixel");*/

        /*  */


		/*
		DFEStructType memoryCommand_t = LMemCommandStream.getLMemCommandDFEStructType();
		DFEStruct memoryCommand = memoryCommand_t.newInstance(this);

		memoryCommand["address"] = address_in_bursts;
		memoryCommand["size"] = constant.var(1).cast(dfeUInt(8));
		memoryCommand["inc"] = constant.var(1).cast(dfeUInt(8));
		memoryCommand["stream"] = constant.var(0).cast(dfeRawBits(15));
		memoryCommand["tag"] = constant.var(false);

		LMemCommandStream.makeKernelOutput("sample_command", constant.var(true), memoryCommand);
		*/

		LMemCommandStream.makeKernelOutput(
				"sample_command",
				constant.var(true),
				addr_burst.cast(dfeUInt(28)),
				constant.var(dfeUInt(8),1),
				constant.var(dfeUInt(7),1),
				constant.var(dfeUInt(4),0),
				constant.var(false));

		io.output("sample_offset_in_pixels", dfeUInt(32)) <== addr_pixel.cast(dfeUInt(32));

	}



}
