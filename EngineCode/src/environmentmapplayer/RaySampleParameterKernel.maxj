package environmentmapplayer;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import displaystandards.DisplayStandard;

class RaySampleParameterKernel extends Kernel {

	private static final DFEType dfefloat = dfeFloat(8, 24);

	public static final DFEStructType SampleParameters_t =
		new DFEStructType(
				DFEStructType.sft("col", dfefloat),
				DFEStructType.sft("row", dfefloat),
				DFEStructType.sft("cam_scalar", dfeInt(8)));

	protected RaySampleParameterKernel(KernelParameters parameters, DisplayStandard displayStandard) throws Exception {
		super(parameters);

		flush.disabled();

		optimization.pushPipeliningFactor(0.25);

		DFEVar col = io.input("col", dfeInt(16)).cast(dfeUInt(32));
		DFEVar row = io.input("row", dfeInt(16)).cast(dfeUInt(32));

		DFEVar offset = io.scalarInput("sampleParameterMapAddress", dfeUInt(32));

		/* Compute the address (in bursts) and offset of the sample to be read */

		float burst_size_in_bytes = 384;
		int bits_per_sample = SampleParameters_t.getTotalBits();
		float bytes_per_sample = bits_per_sample / 8;
		int burst_size_in_bits = (int) (burst_size_in_bytes * 8);
		int samples_per_burst = (int) Math.floor( burst_size_in_bytes / bytes_per_sample);

		DFEVar sample_address_in_samples = (row * displayStandard.H_Active) + col;

		DFEVar sample_address_in_bursts = offset + KernelMath.floor(sample_address_in_samples.cast(dfefloat) / samples_per_burst).cast(dfeUInt(32));
		DFEVar sample_offset_into_burst_in_samples = KernelMath.modulo(sample_address_in_samples, samples_per_burst);


		/* Read the memory, keeping track of what burst address is in the current cache */

        DFEVar previous_address_in_bursts = stream.offset(sample_address_in_bursts, -1);
        DFEVar cache_valid = previous_address_in_bursts.eq(sample_address_in_bursts);

		LMemCommandStream.makeKernelOutput(
				"sample_parameter_read_command",
				~cache_valid,
				sample_address_in_bursts.cast(dfeUInt(28)),
				constant.var(dfeUInt(8),1),
				constant.var(dfeUInt(7),1),
				constant.var(dfeUInt(4),0),
				constant.var(false));

		DFEVar burst = io.input("sample_parameter_read_data", dfeRawBits(burst_size_in_bits), ~cache_valid);
		DFEVar cached_burst = Reductions.streamHold(burst, ~cache_valid);

		/* Read the cache and extract the sample data */

		DFEVar sample_content_shifted = cached_burst.shiftRight((sample_offset_into_burst_in_samples.cast(dfeUInt(MathUtils.bitsToAddress(burst_size_in_bits))) * bits_per_sample));
		DFEVar sample_content = sample_content_shifted.slice(0, bits_per_sample);


		/* Output the sample data */

		io.output("sampleParameters", SampleParameters_t).connect(SampleParameters_t.unpack(sample_content));

		optimization.popPipeliningFactor();

	}

}
