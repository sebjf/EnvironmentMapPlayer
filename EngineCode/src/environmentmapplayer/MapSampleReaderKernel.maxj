package environmentmapplayer;

import java.util.ArrayList;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class MapSampleReaderKernel extends Kernel {

	protected DFEVar clamp(DFEVar v, int min, int max)
	{
		v = v > max ? constant.var(max) : v;
		v = v < min ? constant.var(min) : v;
		return v;
	}

	protected MapSampleReaderKernel(KernelParameters parameters) {
		super(parameters);

		flush.disabled();

		DFEVar bgColour = io.scalarInput("backgroundColour", dfeUInt(32));

		int	burst_size_in_bytes = 384;
		int burst_size_in_bits = burst_size_in_bytes * 8;

		int bits_per_pixel = EnvironmentParameters.pixel_size_in_bytes * 8;
		int pixels_per_word = (int)Math.floor((float)burst_size_in_bytes/(float)EnvironmentParameters.pixel_size_in_bytes);

		DFEVar cache_valid = io.input("cache_valid", dfeBool());

		//DFEVar burst = io.input("burst_input",dfeRawBits(burst_size_in_bits),~cache_valid);

		DFEVar previous_reads_waiting = dfeBool().newInstance(this);

		NonBlockingInput<DFEVar> burst_input =
			io.nonBlockingInput("burst_input", dfeRawBits(burst_size_in_bits), ~cache_valid,
					1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);
		DFEVar burst = Reductions.streamHold(burst_input.data, burst_input.valid);

		DFEVar failed_read = (~cache_valid) & (~(burst_input.valid));

//		//keep track of the number of outstanding reads (cycles were a previous read has failed) the purpose is to empty the incoming buffer even if cache is valid, so
//		//we dont underreport how many misses there are when they are desired

		DFEVar failed_reads = control.count.makeCounter(control.count.makeParams(32).withEnable(failed_read)).getCount();
		DFEVar attempted_reads = control.count.makeCounter(control.count.makeParams(32).withEnable(~cache_valid)).getCount();
		DFEVar successful_reads = control.count.makeCounter(control.count.makeParams(32).withEnable((~cache_valid | previous_reads_waiting) & burst_input.valid)).getCount();

		previous_reads_waiting.connect(stream.offset(successful_reads < attempted_reads, -8));

	//	debug.dfePrintf(failed_read, "Empty Memory on Read in MapSampleReaderKernel. ");//attempted %d successful %d", attempted_reads.cast(dfeUInt(32)), successful_reads.cast(dfeUInt(32)));

		io.scalarOutput("MapSampleReaderKernelFailedReadCount", dfeUInt(32)).connect(failed_reads);
		//io.scalarOutput("MapSampleReaderKernelAttemptedReadCount", dfeUInt(32)).connect(attempted_reads);
		//io.scalarOutput("MapSampleReaderKernelSuccessfulReadCount", dfeUInt(32)).connect(successful_reads);

		//we can't stall the output on this kernel, because it has multiple inputs we have already read so either way we will lose sync

		DFEVar cached_burst = Reductions.streamHold(burst, ~cache_valid);

		DFEVar sample_offset_in_pixels = io.input("sample_offset_in_pixels",dfeUInt(32));

		sample_offset_in_pixels = clamp(sample_offset_in_pixels, 0, pixels_per_word);

		List<DFEVar> samples = new ArrayList<DFEVar>();
		for(int i = 0; i < pixels_per_word; i++)
		{
			samples.add(cached_burst.slice(i * bits_per_pixel, bits_per_pixel));
		}
		samples.add(bgColour.cast(dfeRawBits(32)));
		DFEVar sample_content = control.mux(sample_offset_in_pixels.cast(dfeUInt(MathUtils.bitsToAddress(samples.size()+1))), samples).slice(0,24).cast(dfeUInt(24));

		io.output("sample", dfeUInt(24)) <== sample_content;
	}


}
