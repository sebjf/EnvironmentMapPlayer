package environmentmapplayer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath.Range;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.Bits;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

class EnvironmentMapPlayerKernel extends Kernel {

	private static final DFEType dfechar = dfeUInt(8);
	private static final DFEType dfeuint = dfeInt(32);
	private static final DFEType dfefloat = dfeFloat(8, 24);
	private static final DFEVectorType<DFEVar> vector3 = new DFEVectorType<DFEVar>(dfeFloat(8,24),3);
	private static final DFEVectorType<DFEVar> vector4 = new DFEVectorType<DFEVar>(dfeFloat(8,24),4);

	private static final DFEStructType planeParams_t =
		new DFEStructType(
				DFEStructType.sft("center", vector3),
				DFEStructType.sft("face_offset", dfeuint),
				DFEStructType.sft("u_basis", vector3),
				DFEStructType.sft("v_basis", vector3));

	public static final DFEStructType planeDistance_t =
		new DFEStructType(
				DFEStructType.sft("t", dfefloat),
				DFEStructType.sft("index", dfechar));

	private class Vector3
	{
		public float m_x;
		public float m_y;
		public float m_z;

		public Vector3(float x, float y, float z)
		{
			m_x = x;
			m_y = y;
			m_z = z;
		}

		public List<Float> GetAsList()
		{
			return Arrays.asList(m_x, m_y, m_z);
		}

		public DFEVector<DFEVar> GetAsDFEVector()
		{
			return DFEVectorType.newInstance(Arrays.asList(constant.var(dfefloat, m_x), constant.var(dfefloat, m_y), constant.var(dfefloat, m_z)));
		}
	}

	private class PlaneDefinition
	{
		public Vector3 	m_center;
		public int		m_face_offset;
		public Vector3  m_uBasis;
		public Vector3  m_vBasis;

		public PlaneDefinition(float cx, float cy, float cz, int face, float ux, float uy, float uz, float vx, float vy, float vz )
		{
			m_center = new Vector3(cx,cy,cz);
			m_face_offset = face;
			m_uBasis = new Vector3(ux, uy, uz);
			m_vBasis = new Vector3(vx, vy, vz);
		}

		public Bits getAsBits()
		{
			HashMap<String, Object> memoryMap = new HashMap<String,Object>();

			memoryMap["center"] = m_center.GetAsList();
			memoryMap["face_offset"] = m_face_offset;
			memoryMap["u_basis"] = m_uBasis.GetAsList();
			memoryMap["v_basis"] = m_vBasis.GetAsList();

			return planeParams_t.encodeConstant(memoryMap);
		}
	}

	private Bits[] getPlaneParamsMemContent(PlaneDefinition[] planes)
	{
		ArrayList<Bits> content_segments = new ArrayList<Bits>();
		for (PlaneDefinition def : planes)
		{
			content_segments.add(def.getAsBits());
		}
		return content_segments.toArray(new Bits[content_segments.size()]);
	}

	private <T extends KernelObject<T>> T makeNonBlockingInput(String name, KernelType<T> type)
	{
		NonBlockingInput<T> input =
			io.nonBlockingInput(name, type, constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);
		T data = Reductions.streamHold(input.data, input.valid);
		return data;
	}

	private DFEVar distanceToPlane(PlaneDefinition plane, DFEVector<DFEVar> ray_o, DFEVector<DFEVar> ray_d) throws Exception
	{
		/* calculate the distance to the intersection point */

		DFEVector<DFEVar> a = plane.m_center.GetAsDFEVector();
		DFEVector<DFEVar> n = KernelVectorMath.negate(a);

		DFEVar t = KernelVectorMath.dot(KernelVectorMath.subtract(a, ray_o), n) / KernelVectorMath.dot(n, ray_d);

		return t;
	}

	protected EnvironmentMapPlayerKernel(KernelParameters parameters) throws Exception {
		super(parameters);

		flush.disabled();

		/* Inputs from manager that request this kernel to draw a specific ray */

		DFEVar col = io.input("col", dfeUInt(16)).cast(dfeuint);
		DFEVar row = io.input("row", dfeUInt(16)).cast(dfeuint);

		/* Inputs from host defining how ray should be computed */

		DFEVar viewplane_pixelsize = io.scalarInput("viewplane_pixelsize",dfefloat);
		DFEVar viewplane_viewdistance = io.scalarInput("viewplane_viewdistance", dfefloat);
		DFEVar viewplane_hres = io.scalarInput("viewplane_hres", dfeuint);
		DFEVar viewplane_vres = io.scalarInput("viewplane_vres", dfeuint);

		/* Compute camera orthonormal basis */

		//

		/* Read camera properties on non-blocking stream */

		DFEVector<DFEVar> cam_u = KernelVectorMath.select(makeNonBlockingInput("camera_u", vector4),0,3);
		DFEVector<DFEVar> cam_v = KernelVectorMath.select(makeNonBlockingInput("camera_v", vector4),0,3);
		DFEVector<DFEVar> cam_w = KernelVectorMath.select(makeNonBlockingInput("camera_w", vector4),0,3);

		/* Compute the ray in the camera reference frame */

		DFEVar x_cam = viewplane_pixelsize * (col - (viewplane_hres/2)).cast(dfefloat);
		DFEVar y_cam = viewplane_pixelsize * (row - (viewplane_vres/2)).cast(dfefloat);

		/* Compute the ray in the world reference frame */

		DFEVector<DFEVar> a1 = KernelVectorMath.multiply(x_cam, cam_u);
		DFEVector<DFEVar> a2 = KernelVectorMath.multiply(y_cam, cam_v);
		DFEVector<DFEVar> a3 = KernelVectorMath.multiply(viewplane_viewdistance, cam_w);

		DFEVector<DFEVar> d = KernelVectorMath.subtract(KernelVectorMath.add(a1, a2),a3);
		DFEVector<DFEVar> dn = KernelVectorMath.divide(d, KernelVectorMath.norm(d));

		/* Define the rendering rays */

		DFEVector<DFEVar> r_o = constant.vect(3, dfefloat, 0);
		DFEVector<DFEVar> r_d = dn;

		/* Define the planes */

		PlaneDefinition[] plane_parameters_content = new PlaneDefinition[] {
			new PlaneDefinition( 1, 0, 0,   1,   0, 0,-1,  0, 1, 0), // right
			new PlaneDefinition(-1, 0, 0,   0,   0, 0, 1,  0, 1, 0), // left
			new PlaneDefinition( 0, 1, 0,   3,   1, 0, 0,  0, 0,-1), // down
			new PlaneDefinition( 0,-1, 0,   2,   1, 0, 0,  0, 0, 1), // up
			new PlaneDefinition( 0, 0, 1,   4,   1, 0, 0,  0, 1, 0), // forward
			new PlaneDefinition( 0, 0,-1,   5,  -1, 0, 0,  0, 1, 0)  // back
		};

		/* identify the plane the ray intersects */

		/* This loop should result in the first plane being evaluated, and then compared with the second. Whichever is closer proceeds to be compared with the third, and so on.
		 * Consequently, the selection process is a long pipeline of higher latency, but shorter paths between each computation than would result from multiple parallel comparisons,
		 * making it easier to meet timing. */

		/* For the */

		DFEStruct closestPlane = planeDistance_t.newInstance(this);
		closestPlane["t"] = constant.var(dfefloat, 9999999999999.0f);
		closestPlane["index"] = constant.var(dfechar, 255);

		for (int i = 0; i < plane_parameters_content.length; i++)
		{
			/* Create a result for this comparison */

			DFEStruct currentPlane = planeDistance_t.newInstance(this);
			currentPlane["index"] = constant.var(dfechar, i);
			currentPlane["t"] = distanceToPlane(plane_parameters_content[i], r_o, r_d); 	//Get distance to the current contender for closest plane

			/* Ensure the intersection point is in front of the plane (positive) */

			DFEVar cur_t = currentPlane["t"];
			cur_t = cur_t > 0 ? cur_t : constant.var(dfefloat, 9999999999999.0f);

			/* If closer, replace the current plane identifier */

			DFEVar clos_t = closestPlane["t"];
			closestPlane = cur_t < clos_t ? currentPlane : closestPlane;
		}

		DFEVar plane_index = closestPlane["index"];

		/* Get the full set of parameters for the closest plane */

		DFEStruct plane_parameters = mem.rom(plane_index.cast(dfeUInt(MathUtils.bitsToAddress(6))), planeParams_t, getPlaneParamsMemContent(plane_parameters_content));

		/* calculate the intersection point */

		DFEVector<DFEVar> a = plane_parameters["center"];
		DFEVector<DFEVar> n = KernelVectorMath.negate(a);

		DFEVar t = KernelVectorMath.dot(KernelVectorMath.subtract(a, r_o), n) / KernelVectorMath.dot(n, r_d); //We could replace this with the result in previousResult
		DFEVector<DFEVar> P = KernelVectorMath.add(r_o, KernelVectorMath.multiply(r_d, t));

		/* find the local coordinates on the plane */

		DFEVector<DFEVar> dV = KernelVectorMath.subtract(P, a);

		DFEVector<DFEVar> xc = plane_parameters["u_basis"];
		DFEVector<DFEVar> yc = plane_parameters["v_basis"];

		DFEVar x = KernelVectorMath.dot(dV,xc);
		DFEVar y = KernelVectorMath.dot(dV,yc);

		/* convert local coordinates to texture coordinates */

		DFEVar u = (x / 2) + 0.5;
		DFEVar v = (y / 2) + 0.5;

		/* Determine the mip map level based on the previously sampled location */

		DFEVar pu = stream.offset(u, -1);
		DFEVar pv = stream.offset(v, -1);
		DFEVar du = KernelMath.abs(u - pu);
		DFEVar dv = KernelMath.abs(v - pv);
		DFEVar step_size = KernelMath.max(du, dv);

		// determines the size of the map such that 1 step is 1 pixel.
		//changing 1 to a higher or lower number changes the width so each step covers a larger or smaller number of pixels respectively.
		DFEVar desired_map_width = 1/step_size;

		//here we will use the range to clamp the possible mip map levels to those contained in the source dataset. the actual sample distance may
		//be higher or lower, but the result would be clamped to these anyway.
		Range mip_width_range = new KernelMath.Range(1,2048);
		DFEVar miplevel = KernelMath.ceil(KernelMath.log2(mip_width_range, desired_map_width, dfeFloat(8,24)));


		/* Transmit the sampling parameters to the sampler */

		io.output("plane", dfeUInt(8)).connect((DFEVar) plane_parameters["face_offset"].cast(dfeUInt(8)));
		io.output("miplevel", dfeUInt(8)).connect(miplevel.cast(dfeUInt(8)));
		io.output("u", dfeFloat(8, 24)).connect(u);
		io.output("v", dfeFloat(8, 24)).connect(v);
	}



}
