package environmentmapplayer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath.Range;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.Bits;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

class EnvironmentMapPlayerKernel extends Kernel {

	private static final DFEType dfeuint = dfeInt(32);
	private static final DFEType dfefloat = dfeFloat(8, 24);
	private static final DFEVectorType<DFEVar> vector3 = new DFEVectorType<DFEVar>(dfeFloat(8,24),3);
	private static final DFEVectorType<DFEVar> vector4 = new DFEVectorType<DFEVar>(dfeFloat(8,24),4);

	private static final DFEStructType planeParams_t =
		new DFEStructType(
				DFEStructType.sft("center", vector3),
				DFEStructType.sft("face_offset", dfeuint),
				DFEStructType.sft("x_coefficients", vector3),
				DFEStructType.sft("y_coefficients", vector3));


	/* The next two functions convert a matrix of doubles into an array of Bits objects. Each Bits contains the data for one planeParams_t instance.
	 * When provided to the mem.rom() constructor, the value provided in the DFEVar address specifies an offset into the Bits[]. */

	private Bits[] encodeMemoryContent(double[] content)
	{
		int n_elements_per_row = 10;
		int n_rows = content.length / n_elements_per_row;

		ArrayList<Bits> content_segments = new ArrayList<Bits>();
		for(int i = 0; i < n_rows; i++)
		{
			double [] rowcontent = Arrays.copyOfRange(content, (i * n_elements_per_row), (i * n_elements_per_row) + n_elements_per_row);
			content_segments.add(encodeStructContent(rowcontent));
		}

		return content_segments.toArray(new Bits[content_segments.size()]);
	}

	private Bits encodeStructContent(double[] content)
	{
		HashMap<String, Object> memoryMap = new HashMap<String,Object>();

		memoryMap["center"] = Arrays.asList(content[0], content[1], content[2]);
		memoryMap["face_offset"] = content[3];
		memoryMap["x_coefficients"] = Arrays.asList(content[4], content[5], content[6]);
		memoryMap["y_coefficients"] = Arrays.asList(content[7], content[8], content[9]);

		return planeParams_t.encodeConstant(memoryMap);
	}

	private <T extends KernelObject<T>> T makeNonBlockingInput(String name, KernelType<T> type)
	{
		NonBlockingInput<T> input =
			io.nonBlockingInput(name, type, constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);
		T data = Reductions.streamHold(input.data, input.valid);
		return data;
	}

	protected EnvironmentMapPlayerKernel(KernelParameters parameters) throws Exception {
		super(parameters);

		flush.disabled();

		/* Inputs from manager that request this kernel to draw a specific ray */

		DFEVar col = io.input("col", dfeUInt(16)).cast(dfeuint);
		DFEVar row = io.input("row", dfeUInt(16)).cast(dfeuint);

		/* Inputs from host defining how ray should be computed */

		DFEVar viewplane_pixelsize = io.scalarInput("viewplane_pixelsize",dfefloat);
		DFEVar viewplane_viewdistance = io.scalarInput("viewplane_viewdistance", dfefloat);
		DFEVar viewplane_hres = io.scalarInput("viewplane_hres", dfeuint);
		DFEVar viewplane_vres = io.scalarInput("viewplane_vres", dfeuint);

		/* Compute camera orthonormal basis */

		//

		/* Read camera properties on non-blocking stream */

		DFEVector<DFEVar> cam_u = KernelVectorMath.select(makeNonBlockingInput("camera_u", vector4),0,3);
		DFEVector<DFEVar> cam_v = KernelVectorMath.select(makeNonBlockingInput("camera_v", vector4),0,3);
		DFEVector<DFEVar> cam_w = KernelVectorMath.select(makeNonBlockingInput("camera_w", vector4),0,3);

		/* Compute the ray in the camera reference frame */

		DFEVar x_cam = viewplane_pixelsize * (col - (viewplane_hres/2)).cast(dfefloat);
		DFEVar y_cam = viewplane_pixelsize * (row - (viewplane_vres/2)).cast(dfefloat);

		/* Compute the ray in the world reference frame */

		DFEVector<DFEVar> a1 = KernelVectorMath.multiply(x_cam, cam_u);
		DFEVector<DFEVar> a2 = KernelVectorMath.multiply(y_cam, cam_v);
		DFEVector<DFEVar> a3 = KernelVectorMath.multiply(viewplane_viewdistance, cam_w);

		DFEVector<DFEVar> d = KernelVectorMath.subtract(KernelVectorMath.add(a1, a2),a3);
		DFEVector<DFEVar> dn = KernelVectorMath.divide(d, KernelVectorMath.norm(d));

		/* Define the rendering rays */

		DFEVector<DFEVar> r_o = constant.vect(3, dfefloat, 0);
		DFEVector<DFEVar> r_d = dn;

		/* identify the plane the ray intersects */

		DFEVar plane_axis_index = KernelVectorMath.max(KernelVectorMath.abs(r_d), KernelVectorMath.indicesVector(r_d));
		DFEVar plane_axis = KernelVectorMath.max(KernelVectorMath.abs(r_d), r_d);

		plane_axis_index = plane_axis_index * 2;

		DFEVar plane_index = (plane_axis < 0) ? (plane_axis_index + 1) : plane_axis_index;

		/* Lookup the parameters of the plane */

		double[] plane_parameters_content = {
				 1, 0, 0,   1,   0, 0,-1,  0, 1, 0, // right
				-1, 0, 0,   0,   0, 0, 1,  0, 1, 0, // left
				 0, 1, 0,   3,   1, 0, 0,  0, 0,-1, // down
				 0,-1, 0,   2,   1, 0, 0,  0, 0, 1, // up
				 0, 0, 1,   4,   1, 0, 0,  0, 1, 0, // forward
				 0, 0,-1,   5,  -1, 0, 0,  0, 1, 0, // back
		};

		DFEStruct plane_parameters = mem.rom(plane_index.cast(dfeUInt(MathUtils.bitsToAddress(6))), planeParams_t, encodeMemoryContent(plane_parameters_content));

		/* calculate the intersection point */

		DFEVector<DFEVar> a = plane_parameters["center"];
		DFEVector<DFEVar> n = KernelVectorMath.negate(a);

		DFEVar t = KernelVectorMath.dot(KernelVectorMath.subtract(a, r_o), n) / KernelVectorMath.dot(n, r_d);
		DFEVector<DFEVar> P = KernelVectorMath.add(r_o, KernelVectorMath.multiply(r_d, t));

		/* find the local coordinates on the plane */

		DFEVector<DFEVar> dV = KernelVectorMath.subtract(P, a);

		DFEVector<DFEVar> xc = plane_parameters["x_coefficients"];
		DFEVector<DFEVar> yc = plane_parameters["y_coefficients"];

		DFEVar x = KernelVectorMath.dot(dV,xc);
		DFEVar y = KernelVectorMath.dot(dV,yc);

		/* convert local coordinates to texture coordinates */

		DFEVar u = (x / 2) + 0.5;
		DFEVar v = (y / 2) + 0.5;

		/* Determine the mip map level based on the previously sampled location */

		DFEVar pu = stream.offset(u, -1);
		DFEVar pv = stream.offset(v, -1);
		DFEVar du = KernelMath.abs(u - pu);
		DFEVar dv = KernelMath.abs(v - pv);
		DFEVar step_size = KernelMath.max(du, dv);

		// determines the size of the map such that 1 step is 1 pixel.
		//changing 1 to a higher or lower number changes the width so each step covers a larger or smaller number of pixels respectively.
		DFEVar desired_map_width = 1/step_size;

		//here we will use the range to clamp the possible mip map levels to those contained in the source dataset. the actual sample distance may
		//be higher or lower, but the result would be clamped to these anyway.
		Range mip_width_range = new KernelMath.Range(1,2048);
		DFEVar miplevel = KernelMath.ceil(KernelMath.log2(mip_width_range, desired_map_width, dfeFloat(8,24)));


		//DFEVar miplevel = constant.var(9);

		/* Transmit the sampling parameters to the sampler */

		io.output("plane", dfeUInt(8)).connect((DFEVar) plane_parameters["face_offset"].cast(dfeUInt(8)));
		io.output("miplevel", dfeUInt(8)).connect(miplevel.cast(dfeUInt(8)));
		io.output("u", dfeFloat(8, 24)).connect(u);
		io.output("v", dfeFloat(8, 24)).connect(v);
	}



}
