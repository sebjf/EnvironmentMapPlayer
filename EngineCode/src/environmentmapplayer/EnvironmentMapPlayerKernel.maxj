package environmentmapplayer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.DelimiterMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingInput;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.IO.NonBlockingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelObject;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.KernelType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.Bits;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

class EnvironmentMapPlayerKernel extends Kernel {

	private static final DFEType dfeuint = dfeInt(32);
	private static final DFEType dfefloat = dfeFloat(8, 24);
	private static final DFEVectorType<DFEVar> vector3 = new DFEVectorType<DFEVar>(dfeFloat(8,24),3);
	private static final DFEVectorType<DFEVar> vector4 = new DFEVectorType<DFEVar>(dfeFloat(8,24),4);

	private static final DFEStructType planeParams_t =
		new DFEStructType(
				DFEStructType.sft("center", vector3),
				DFEStructType.sft("offsetx", dfeuint),
				DFEStructType.sft("offsety", dfeuint),
				DFEStructType.sft("x_coefficients", vector3),
				DFEStructType.sft("y_coefficients", vector3));


	private Bits[] encodeMemoryContent(double[] content)
	{
		int rows = content.length / 11;

		ArrayList<Bits> content_segments = new ArrayList<Bits>();
		for(int i = 0; i < rows; i++)
		{
			double [] rowcontent = Arrays.copyOfRange(content, (i * 11), (i * 11) + 11);
			content_segments.add(encodeStructContent(rowcontent));
		}

		return content_segments.toArray(new Bits[content_segments.size()]);
	}

	private Bits encodeStructContent(double[] content)
	{
		HashMap<String, Object> memoryMap = new HashMap<String,Object>();

		memoryMap["center"] = Arrays.asList(content[0], content[1], content[2]);
		memoryMap["offsetx"] = content[3];
		memoryMap["offsety"] = content[4];
		memoryMap["x_coefficients"] = Arrays.asList(content[5], content[6], content[7]);
		memoryMap["y_coefficients"] = Arrays.asList(content[8], content[9], content[10]);

		return planeParams_t.encodeConstant(memoryMap);
	}

	private <T extends KernelObject<T>> T makeNonBlockingInput(String name, KernelType<T> type)
	{
		NonBlockingInput<T> input =
			io.nonBlockingInput(name, type, constant.var(true), 1, DelimiterMode.FRAME_LENGTH, 0, NonBlockingMode.NO_TRICKLING);
		T data = Reductions.streamHold(input.data, input.valid);
		return data;
	}

	protected EnvironmentMapPlayerKernel(KernelParameters parameters) throws Exception {
		super(parameters);

		flush.disabled();

		/* Inputs from manager that request this kernel to draw a specific ray */

		DFEVar col = io.input("col", dfeUInt(16)).cast(dfeuint);
		DFEVar row = io.input("row", dfeUInt(16)).cast(dfeuint);

		/* Inputs from host about the environment map */
		DFEVar map_width = io.scalarInput("map_width", dfeuint);
		DFEVar map_height = io.scalarInput("map_height", dfeuint);
		DFEVar segment_width = io.scalarInput("segment_width",dfeuint);
		DFEVar segment_height = io.scalarInput("segment_height",dfeuint);

		/* Inputs from host defining how ray should be computed */

		DFEVar viewplane_pixelsize = io.scalarInput("viewplane_pixelsize",dfefloat);
		DFEVar viewplane_viewdistance = io.scalarInput("viewplane_viewdistance", dfefloat);
		DFEVar viewplane_hres = io.scalarInput("viewplane_hres", dfeuint);
		DFEVar viewplane_vres = io.scalarInput("viewplane_vres", dfeuint);

		/* Compute camera orthonormal basis */

		//

		/* Read camera properties on non-blocking stream */

		DFEVector<DFEVar> cam_u = KernelVectorMath.select(makeNonBlockingInput("camera_u", vector4),0,3);
		DFEVector<DFEVar> cam_v = KernelVectorMath.select(makeNonBlockingInput("camera_v", vector4),0,3);
		DFEVector<DFEVar> cam_w = KernelVectorMath.select(makeNonBlockingInput("camera_w", vector4),0,3);

		/* Compute the ray in the camera reference frame */

		DFEVar x_cam = viewplane_pixelsize * (col - (viewplane_hres/2)).cast(dfefloat);
		DFEVar y_cam = viewplane_pixelsize * (row - (viewplane_vres/2)).cast(dfefloat);

		/* Compute the ray in the world reference frame */

		DFEVector<DFEVar> a1 = KernelVectorMath.multiply(x_cam, cam_u);
		DFEVector<DFEVar> a2 = KernelVectorMath.multiply(y_cam, cam_v);
		DFEVector<DFEVar> a3 = KernelVectorMath.multiply(viewplane_viewdistance, cam_w);

		DFEVector<DFEVar> d = KernelVectorMath.subtract(KernelVectorMath.add(a1, a2),a3);
		DFEVector<DFEVar> dn = KernelVectorMath.divide(d, KernelVectorMath.norm(d));

		/* Define the rendering rays */

		DFEVector<DFEVar> r_o = constant.vect(3, dfefloat, 0);
		DFEVector<DFEVar> r_d = dn;

		/* identify the plane the ray intersects */

		DFEVar plane_axis_index = KernelVectorMath.max(KernelVectorMath.abs(r_d), KernelVectorMath.indicesVector(r_d));
		DFEVar plane_axis = KernelVectorMath.max(KernelVectorMath.abs(r_d), r_d);

		plane_axis_index = plane_axis_index * 2;

		DFEVar plane_index = (plane_axis < 0) ? (plane_axis_index + 1) : plane_axis_index;

		/* Lookup the parameters of the plane */

		double[] plane_parameters_content = {
				 1, 0, 0,   2, 1,   0, 0,-1,  0, 1, 0, // right
				-1, 0, 0,   0, 1,   0, 0, 1,  0, 1, 0, // left
				 0, 1, 0,   1, 2,   1, 0, 0,  0, 0,-1, // down
				 0,-1, 0,   1, 0,   1, 0, 0,  0, 0, 1, // up
				 0, 0, 1,   1, 1,   1, 0, 0,  0, 1, 0, // forward
				 0, 0,-1,   3, 1,  -1, 0, 0,  0, 1, 0, // back
		};

		DFEStruct plane_parameters = mem.rom(plane_index.cast(dfeUInt(MathUtils.bitsToAddress(6))), planeParams_t, encodeMemoryContent(plane_parameters_content));

		/* calculate the intersection point */

		DFEVector<DFEVar> a = plane_parameters["center"];
		DFEVector<DFEVar> n = KernelVectorMath.negate(a);

		DFEVar t = KernelVectorMath.dot(KernelVectorMath.subtract(a, r_o), n) / KernelVectorMath.dot(n, r_d);
		DFEVector<DFEVar> P = KernelVectorMath.add(r_o, KernelVectorMath.multiply(r_d, t));

		/* find the local coordinates on the plane */

		DFEVector<DFEVar> dV = KernelVectorMath.subtract(P, a);

		DFEVector<DFEVar> xc = plane_parameters["x_coefficients"];
		DFEVector<DFEVar> yc = plane_parameters["y_coefficients"];

		DFEVar x = KernelVectorMath.dot(dV,xc);
		DFEVar y = KernelVectorMath.dot(dV,yc);

		/* convert local coordinates to texture coordinates */

		DFEVar u = (x / 2) + 0.5;
		DFEVar v = (y / 2) + 0.5;

		/* Convert the coordinates to addresses */

		DFEVar horizontal_segment_offset = plane_parameters["offsetx"];
		DFEVar tu = (u *  segment_width.cast(dfefloat)).cast(dfeuint) + (horizontal_segment_offset * segment_width);
		DFEVar vertical_segment_offset = plane_parameters["offsety"];
		DFEVar tv = (v * segment_height.cast(dfefloat)).cast(dfeuint) + (vertical_segment_offset * segment_height);

		DFEVar address = (tv * map_width) + tu;

		io.output("address", dfeUInt(32)) <== address.cast(dfeUInt(32));

		address.cast(dfeUInt(32)).simWatch("address");
	}



}
